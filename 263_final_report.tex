%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}


\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{20yy} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Title Text}
\subtitle{Subtitle Text, if any}

\authorinfo{Peter Kraft}
           {pkraft@college.harvard.edu}
\authorinfo{Jonah Kallenbach}
           {kallenbach@college.harvard.edu}
\authorinfo{Jonah Kallenbach Shai Szulanski}
           {sszulanski@college.harvard.edu}

\maketitle

Cross-site scripting (XSS) vulnerabilities are now the most widely reported security bugs in the world of web application development.  Modern web frameworks like Django, a web development framework which allows for rapid prototyping, deployment, and scaling, claim to shield against such attacks, and indeed provide many important protections.  However, in many cases, these frameworks fail to provide complete coverage, leaving developers feeling secure, but potentially open to XSS vulnerabilities.  We used the web testing framework Selenium to create a testing suite for XSS vulnerabilities in Django web applications.  While our tool is not completely comprehensive, it covers many of the most common and most dangerous XSS attacks, is lightweight and easy to use, and requires very little effort from the user. Before deploying their web application, Django developers can now use our testing suite to determine if they have XSS vulnerabilities and eliminate them -- preventing potentially critical security flaws from being exposed to the world.

\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

TODO:
finish paper
add usage information to the readme
deal with multiple pages

Motivation for project

Web applications now pervade nearly every aspect of our daily lives.  Unfortunately, in many cases, they can be vulnerable to various attacks which exploit poorly written code to maliciously steal sensitive information from a server or critically compromise the web application for use by other clients.  One common route for such attacks is so called 'cross-site scripting' vulnerabilities.  In these attacks, the attacker finds a location where code injection can be performed, and, through social engineering, email, or some other form of communication, gets the victim to open a link which executes the malicious code in the victim’s browser.  Another attack vector is convincing the application to store the malicious code in the web application’s database, and then the code may be executed when that database entry is served to other users. This often results in leakage of private information to the attacker, or even the attacker commandeering the victim’s browser.  As websites have become increasingly dynamic rather than static, such attacks have become increasingly common -- today XSS vulnerabilities constitute the plurality of publicly reported security flaws, exceeding even buffer overflows.
In general, such attacks are easily preventable with proper sanitization of inputs to the web application.  This can be done either via careful input validation (which can be extremely difficult in cases where the application is supposed to handle markup), or by using built-in language or package constructs to sanitize inputs (for example, turning on filtering in PHP).  
Unfortunately, developers frequently fail to use these tools, or err in doing custom input validation, for example by using a blacklist instead of a whitelist and forgetting a malicious pattern.  Several modern web frameworks aim to alleviate these issues, though we will focus on the Django framework for Python.
Django is a Python web framework which is designed to allow for quick prototyping, easy scaling, and to provide “multiple protection tools and mechanisms” for security protection.  Django takes care of writing all of the boilerplate server and frontend code which usually makes web application development so time consuming and bug prone.  It also provides built-in modular divisions for the web application code (which it calls, similar to the classic model-view-controller paradigm, ‘model-template-view’).  Django’s shared nothing architecture allows for additional hardware to be added easily, making scaling up a production web application quite simple.  On the security front, Django provides a number of useful features for the application developer: XSS protection via template auto-escaping, CSRF protection via specialized middleware which checks HTTP referer headers, SQL injection protection via the Django SQL subset, and much more. However, despite the many useful features outlined above, Django to some degree lulls application developers into thinking their websites are completely secure -- but this very well may not be the case, as each of the protections listed above has notable exceptions.
While Django is an extraordinarily useful framework which allows rapid development, modular design, and can even provide protection against many common security mistakes, it is not invulnerable to attacks, including XSS.  Such attacks can remain effective against web applications made with Django in several situations. 

Related Work
The plurality of proposed solutions to XSS vulnerabilities occur at the prevention level, as with the built-in sanitization described above. Such prevention is imperfect and inconsistently applied, and has subtle edge cases that can be exploited to create undetectable (by those tools) attacks, so testing for vulnerabilities is also an area of interest. The most prevalent method is manual testing, whether by human or unit test. This is labor-intensive and it is easy to miss a particular case that would reveal a vulnerability.
As a result, automated methods were developed, many of which center around taint tracking. The most notable is perl’s taint mode, which at the time was the most extensive integration of this sort of security feature into a commonly used programming language. Similar projects emerged for other programming languages, and for client-side detection of attacks. But taint tracking is subject to taint explosion, so subsequent work employs static analysis to search for vulnerabilities. A result of this research is a client-side program for detecting potential XSS vulnerabilities via taint tracking and static analysis which allows the user to decide whether to allow the request, though depending on the user to make security decisions on the fly often leads to trouble. 
Another approach uses end-to-end testing in a sort of dynamic brute-force search for vulnerabilities, incorporating heuristics to limit the time required. Frameworks have been developed to generalize the technique. 
Our contribution is a framework integrated into Django, which uses an extensive collection of XSS attacks to search for vulnerabilities while being easy enough for untrained developers to use routinely. 

Threat model
We consider an attacker with the ability to make arbitrary HTTP GET/POST requests through publicly exposed HTTP interfaces that affect the content displayed in the web application. Though this does not include all threats a web service faces, notably including access to any of the servers by exploiting vulnerabilities in e.g. the http daemon used, the excluded attack vectors typically occur because of server configuration issues (including failing to update apache) that are unlikely to affect the burgeoning developer hosting on AWS. Our threat model focuses on vulnerabilities intrinsic to the Django application being tested. The particular class of attacks we seek to catch are cross-site scripting or XSS attacks, where untrusted JavaScript is executed in the browser within the domain of the web application, allowing the attacker to insert unsafe function calls that e.g. provide increased permission levels or exfiltrate data.

Precise description of the proposed solution

Evaluation of the proposed solution

We believe our project succeeds at its goal of being a lightweight, easy to use XSS penetration tester for Django apps.  Compared to commercial XSS testers like OWASP's Xenotix, it certainly is simple.  All of the active code lives in a single Python script and a single configuration file that lists potential XSS attack strings.  The only dependencies besides Django are Selenium and an up-to-date Firefox for the Selenium webdriver, both of which are reasonable and easy-to-install requirements (in fact, most web developers will already have them).  The entire installation process for our tool consists of dropping the two files into the Django project's root directory.  And because the code is self-contained and written within Django, it's relatively easy for a user to customize as necessary to fit their needs.  The importance of this simplicity cannot be underestimated.  The largest barrier to entry preventing people from penetration-testing their websites, even against near-ubiquitous threats like XSS, is the complexity and inaccessibility of most common tools.  Providing a simple, framework-integrated 
Our tool is capable of detecting most types of XSS vulnerabilities, including any vulnerable query strings or text fields that fail to sanitize user input.  This covers the most dangerous types of attacks--especially vulnerable query strings, because those can be used to create malicious links that silently transform a trusted site into a compromised one.  

Conclusion
We demonstrate that security tools can be simple to install and use so that they are accessible to less experienced developers and can protect them from common (and less common) mistakes that lead to their application being vulnerable. We believe that integrating security tools into popular application frameworks like Django is a valuable step in the ubiquitization of security practices. Our application is also highly extensible, allowing additional vulnerabilities to be added to the tool as their importance is discovered. 


\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

